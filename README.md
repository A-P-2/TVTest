# TVTest
![image](https://github.com/A-P-2/TVTest/assets/57561034/4571383b-c71c-459c-83e7-8ebd298ddb29)

В папке "TVTest" находится проект C#, написанный с использованием .NET 7.0 (не рекомендуется запускать проект на более ранних версиях .NET, так как это может привести к синтаксическим ошибкам в коде). В папке "Сборка" находятся 2 exe-файла, для запуска сервера и клиента соответственно. Приложение можно запускать как через exe-файлы, так и в самом проекте через среду программирования вроде Visual Studio и т.д. На одном компьютере можно запускать только один сервер и множество клиентов. Порядок запуска неважен, но у всех клиентов, запущенных раньше сервера, в списке событий вместо ip-адреса будет отображаться "???" до тех пор, пока эти клиенты не попросят сервер ещё раз записать их ip-адреса (подробнее ниже). 
Передача данных происходит через порт 5000. Если данный порт уже задействован, необходимо изменить порт в проекте: у клиента в файле "program.cs" при создании объекта класса UDPClient, на сервере в файле "UDPServer.cs" атрибут "port".
## Архитектура и способ подключения
События, которые клиент отсылает серверу хранятся в виде объекта класса Data. В данном классе присутствует 4 поля (имя устройства, целое число, вещ. число, строка), а также функции для преобразования объекта в строку JSON и обратно.
### Сервер
Состоит из 2-х модулей. Один модуль отвечает за сбор и обработку событий, другой - за работу с базой данных. Модуль базы данных подключается к обработчику событий через интерфейс - это сделано для того, чтобы в случае необходимости перехода на другую БД можно было переписать только модуль БД, не трогая при этом сам обработчик. В данном проекте не происходит подключения к реальной БД, вместо этого данные хранятся в 2-х списках, представляющих собой условные таблицы БД: таблица устройств и таблица событий. Сделано это для того, чтобы было проще продемонстрировать работу приложения, без необходимости разворачивать на компьютере необходимую СУБД. В реальных условиях думаю будет лучше всего использовать нереляционную базу данных с возможностью распределения, так как объём данных очень большой.
Передача данных происходит по протоколу UDP, так как данный протокол не требует открывать соединение между клиентом и сервером. Поскольку в задании сказано, что данные будут ежесекундно собираться с 20000 устройств - открывать для этого 20000 соединений мне показалось.. не лучшей идеей. Не уверен, можно ли использовать UDP в реальных условиях, думаю тут всё упирается в размер отдельного сообщения, посылаемого клиентом, а также, допустимы ли в данной задаче случайные потери данных или изменение порядка сообщений. Если это критично, то необходимо будет рассмотреть более сложные подходы, вроде использования REST, gRPC и т.п.
Работа сервера разделена на несколько потоков:
* Главный поток - подключается к БД, передаёт модуль управления БД обработчику событий, и затем начинает просматривать команды, вводимые в консоль: show - показать список событий, exit - завершить работу сервера.
* Поток регистрации - просматривает очередь запросов на регистрацию. Если очередь пуста - засыпает на 1 секунду.
* Поток обработки событий - просматривает очередь событий. Если очередь пуста - засыпает на 1 секунду.
* Поток сообщений - прослушивает сообщения от клиентов. При появлении нового сообщения, определяет тип запроса и добавляет его в соответствующую очередь.
### Клиент
При запуске запрашивает ввод имени устройства. Подразумевается, что у всех клиентов будут свои уникальные имена (проверка на повторы не производится).
Работа сервера разделена на несколько потоков:
* Главный поток - запрашивает имя устройства, затем начинает просматривать команды, вводимые в консоль: exit - завершить работу сервера.
* Поток регистрации - раз в 5 минут посылает на сервер запрос на регистрацию в формате "_имя".
* Поток событий - эмитирует работу датчика. Раз в секунду создаёт объект класса Data, в который записывает своё имя и 3 случайных значения (int, float string). Затем, данные преобразуются в строку JSON и отправляются на сервер.
## Регистрация устройства с занесением его в базу данных
Если на сервер пришло сообщение, начинающееся с символа "_" - значит это запрос на регистрацию. Сервер добавляет в очередь на регистрацию кортеж, состоящий из двух значений: 1 - имя устройства (всё сообщение без символа _), 2 - ip-адрес устройства, откуда пришло сообщение. В дальнейшем поток регистрации внесёт эти данные в таблицу устройств. Если название устройства уже присутствует в таблице, у него просто обновляется ip-адрес.
## Регистрация нового события для конкретного устройства с занесением ее в базу данных
Если на сервер пришло сообщение, не начинающееся с символа "_" - значит это запрос на добавление нового события в виде JSON строки. Данная строка преобразуется в объект класса Data и добавляется в очередь обработки событий. В дальнейшем поток обработки событий внесёт эти данные в таблицу событий.
## Обработка запроса списка событий
Признаюсь честно, я не до конца понял должен ли этот запрос приходит от клиента (и соответственно, сервер должен вернуть клиенту ответ), или же этот запрос происходит непосредственно на самом сервере и никуда не отсылает данные. Поскольку в задании речь шла о датчиках, я предположил, что датчики будут только посылать данные и не будут что-либо просить обратно, поэтому я реализовал запрос на самом сервере (если это всё таки нужно было делать на клиенте, то делается это аналогично с сервером: на клиенте создаётся поток для прослушивания сообщений, а сервер отсылает ответ по тому же ip-адресу, откуда пришёл запрос).
Если в консоли сервера вбить команду show, отобразится список всех событий. В данном списке будут объединены обе таблицы: устройства и события - то есть у каждого устройства, помимо случайных данных, будет ещё прописан последний зарегистрированный ip-адрес. При вызове функции отображения данных модулю работы с БД передаётся делегат обработки отдельной строки данных. Таким образом можно указать, как именно мы хотим отобразить данные: в консоли, на пользовательском интерфейсе, записать в файл и т.д.
